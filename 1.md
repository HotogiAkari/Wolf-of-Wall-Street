### **【短期优化】 立竿见-影的性能提升 (Low-Hanging Fruit)**

这些是您可以立即着手、且能快速看到效果的优化点。

#### **2. 丰富特征维度**
*   **当前状态**: 我们主要使用了基础的价格衍生技术指标。
*   **优化方向**: 在不增加代码复杂度的前提下，充分利用现有框架，从 `config.yaml` 入手，引入更多类型的特征。
*   **具体操作**:
    1.  **增加技术指标**: 查阅 `pandas-ta` 的官方文档，在 `config.yaml` 的 `technical_indicators` 列表中，加入更多您感兴趣的指标，例如波动率指标 (`atr`)、动量指标 (`roc`) 或成交量相关的指标 (`obv`)。
    2.  **启用 K 线模式**: 在 `global_settings` 下的 `candlestick_patterns` 列表中，加入一些经典的 K 线模式名称，例如 `cdl_doji`, `cdl_hammer`, `cdl_engulfing`。
*   **预期效果**: 为模型提供更多维度的“视角”来观察市场，有可能发现新的规律，提升 ICIR。

##### **1. 如何丰富特征维度？需要修改哪些 `.py` 文件？**

这取决于您想增加的特征类型。您的框架设计得非常好，对于不同类型的特征，修改的地方也不同：

###### **A. 增加更多 `pandas-ta` 支持的技术指标**

*   **需要修改的文件**: **`configs/config.yaml` (唯一需要修改的文件)**
*   **如何操作**:
    1.  查阅 [pandas-ta 官方指标文档](https://github.com/twopirllc/pandas-ta#indicators-by-category)。
    2.  找到您感兴趣的指标，例如波动率指标 `atr` (平均真实波幅)。
    3.  在 `config.yaml` 的 `global_settings.technical_indicators` 列表中，加入新的条目：
        ```yaml
        technical_indicators:
          - name: "ema"
            params: {"length": 10}
          # ...
          - name: "atr" # <--- 新增
            params: {"length": 14}
        ```
*   **原理**: `feature_calculators.py` 中的 `TechnicalIndicatorCalculator` 会自动读取这个列表，并动态调用 `df.ta.atr(length=14, ...)`，无需修改任何 Python 代码。

###### **B. 增加需要复杂计算的自定义特征 (例如，资金流、情绪因子)**

*   **需要修改的文件**: **`data_process/feature_calculators.py`**
*   **如何操作**:
    1.  打开 `feature_calculators.py` 文件。
    2.  创建一个**新的类**，继承自 `FeatureCalculator` 基类。
    3.  在这个新类中，实现 `calculate` 方法，编写您复杂的特征计算逻辑。例如，您可能需要从 Tushare 获取“每日个股资金流向”数据，并将其与价格数据合并计算。
        ```python
        # data_process/feature_calculators.py
        
        class MoneyFlowCalculator(FeatureCalculator):
            @property
            def name(self) -> str:
                return "Money Flow Features"
        
            def calculate(self, df: pd.DataFrame) -> pd.DataFrame:
                print(f"  - [Calculating Features] Running: {self.name}...")
                ticker = self.config.get('ticker') # 从 config 获取当前股票代码
                # ... (调用 Tushare API 获取该股票的资金流数据)
                # ... (将资金流数据与 df 按日期合并)
                # ... (计算您的自定义资金流因子，例如“主力净流入占比”)
                # df['mflow_ratio'] = ...
                return df
        ```
    4.  最后，将您创建的新类，注册到文件底部的 `ALL_CALCULATORS` 列表中：
        ```python
        ALL_CALCULATORS = [
            TechnicalIndicatorCalculator,
            CalendarFeatureCalculator,
            CandlestickPatternCalculator,
            MoneyFlowCalculator, # <--- 在这里注册
        ]
        ```
*   **原理**: `get_data.py` 中的 `run_all_feature_calculators` 函数会自动发现并运行您所有注册的计算器。

---
### **2. 如何集成“多因子模型”作为基准？**

我们将通过以下步骤，将您的项目升级为基于**法马-佛伦奇三因子模型 (Fama-French 3-Factor Model)** 进行研究。

#### **核心思想的转变**

*   **旧目标 (y)**: `label_return` = 未来 30 天的**原始收益率**。
*   **新目标 (y)**: `label_alpha` = 未来 30 天的**风险中性 Alpha**。

`Alpha = 原始收益率 - (β_mkt * 市场风险溢价 + β_smb * 市值因子收益 + β_hml * 价值因子收益)`

我们将通过回归，从原始收益率中“剥离”掉由市场整体涨跌、大小盘风格轮动、价值/成长风格轮动所带来的影响，剩下的“残差”部分，就是我们真正想要模型去预测的、纯粹的 Alpha。

---

#### **实施步骤**

##### **第一步：获取因子数据**

我们需要一个新的数据源来获取A股市场的三因子（或五因子）收益率序列。一个常见的、免费的来源是 **CSMAR 数据库**，或者一些提供学术数据的网站。

为了方便，我们将**模拟**这个过程，并创建一个新的函数来**生成因子数据**（在真实研究中，您需要替换为从真实数据源加载）。

**请在 `data_process/` 目录下，创建一个新文件 `factor_data.py`:**

```python
# 文件路径: data_process/factor_data.py (新增文件)

import pandas as pd
import numpy as np

def get_fama_french_factors(start_date: str, end_date: str) -> pd.DataFrame:
    """
    获取法马-佛伦奇三因子（A股市场）的日收益率数据。
    
    【注意】: 这是一个模拟实现！在真实研究中，您需要替换此函数，
    使其从 CSMAR、Wind、Quandl 等真实数据源加载因子数据。
    """
    print("  - INFO: Loading Fama-French 3 factors (simulated data)...")
    
    dates = pd.date_range(start=start_date, end=end_date, freq='B') # 'B' for business day
    n_days = len(dates)
    
    # 模拟每日的因子收益率（正态分布，有微小的正向漂移）
    mkt_rf = np.random.normal(loc=0.0002, scale=0.015, size=n_days) # 市场风险溢价
    smb = np.random.normal(loc=0.0001, scale=0.008, size=n_days)   # 市值因子 (小盘 - 大盘)
    hml = np.random.normal(loc=0.0001, scale=0.007, size=n_days)   # 价值因子 (高B/M - 低B/M)
    rf = np.full(n_days, 0.02 / 252) # 无风险利率 (年化2%)
    
    factors_df = pd.DataFrame({
        'date': dates,
        'mkt_rf': mkt_rf,
        'smb': smb,
        'hml': hml,
        'rf': rf
    }).set_index('date')
    
    return factors_df
```

##### **第二步：修改 `get_data.py` 以计算 Alpha**

我们将修改核心数据处理流水线，增加一个全新的步骤：**计算 Alpha**。

**请用下面的完整代码，彻底覆盖您现有的 `data_process/get_data.py` 文件。**

这个版本引入了 `factor_data.py`，并重写了 `_create_and_clean_labels` 函数，使其计算 `label_alpha`。

```python
# 文件路径: data_process/get_data.py (最终多因子版)

# ... (保留所有 import) ...
# --- 新增导入 ---
from data_process.factor_data import get_fama_french_factors
import statsmodels.api as sm
# ---

# ... (保留 initialize_apis, shutdown_apis, _download_with_retry, _get_api_ticker, _get_ohlcv_data_bs, _get_macroeconomic_data_cn) ...

# --- 【函数重写】: 不再需要 relative_performance，因为因子模型更高级 ---
# def _add_relative_performance_features(...):
#     pass

# --- 【函数重写】: _create_and_clean_labels 现在计算 Alpha ---
def _calculate_alpha_label(df: pd.DataFrame, factors_df: pd.DataFrame, run_config: dict) -> pd.DataFrame:
    """
    (已重构) 通过多因子模型回归，计算未来收益率的 Alpha 作为预测标签。
    """
    print("  - [6/7] 正在通过因子模型计算 Alpha 标签...")
    
    horizon = run_config.get("labeling_horizon", 30)
    label_col = run_config.get('label_column', 'label_alpha') # <-- 标签名改为 alpha
    
    # 1. 计算股票的原始超额收益率 (未来 N 日)
    df['future_return'] = df['close'].pct_change(periods=horizon).shift(-horizon)
    df_merged = df.join(factors_df, how='left')
    df_merged['excess_return'] = df_merged['future_return'] - df_merged['rf']

    # 2. 准备回归数据
    # 我们使用过去一年的数据来为每个时间点估计因子暴露 (Betas)
    rolling_window = 252 
    
    alphas = []
    
    # 这个循环比较慢，在生产中可以向量化优化
    for i in range(rolling_window, len(df_merged)):
        # 定义回归窗口
        window_df = df_merged.iloc[i - rolling_window : i]
        
        # 准备 Y (历史超额收益) 和 X (历史因子收益)
        Y = window_df['excess_return'].dropna()
        X = window_df[['mkt_rf', 'smb', 'hml']].loc[Y.index]
        X = sm.add_constant(X) # 添加截距项
        
        if len(Y) < 20: # 如果有效数据太少
            alphas.append(np.nan)
            continue
            
        # 运行 OLS 回归
        model = sm.OLS(Y, X).fit()
        betas = model.params
        
        # 3. 计算 Alpha
        # Alpha = 当期的未来超额收益 - 当期的因子暴露 * 当期的未来因子收益
        # 为了简化，我们使用回归的残差作为当期 Alpha 的近似
        # (更严谨的方法是预测未来因子收益，但这超出了本示例范围)
        
        # 获取当前时间点的未来超额收益和因子收益
        current_excess_return = df_merged['excess_return'].iloc[i]
        current_factors = df_merged[['mkt_rf', 'smb', 'hml']].iloc[i]
        
        if pd.isna(current_excess_return) or current_factors.isnull().any():
            alphas.append(np.nan)
            continue
            
        # 计算预期收益 = 因子暴露 * 因子收益
        expected_return = (betas['mkt_rf'] * current_factors['mkt_rf'] + 
                           betas['smb'] * current_factors['smb'] + 
                           betas['hml'] * current_factors['hml'])
                           
        # Alpha = 真实超额收益 - 预期超额收益
        alpha = current_excess_return - expected_return
        alphas.append(alpha)

    # 将计算出的 Alpha 序列添加到 DataFrame
    df[label_col] = pd.Series(alphas, index=df_merged.index[rolling_window:])
    
    # 对 Alpha 进行去极值处理
    lower_bound = df[label_col].quantile(0.01)
    upper_bound = df[label_col].quantile(0.99)
    df[label_col] = df[label_col].clip(lower=lower_bound, upper=upper_bound)
    
    return df

# --- 【函数重构】: get_full_feature_df 的流水线发生变化 ---
def get_full_feature_df(ticker: str, config: Dict, keyword: str = None) -> Optional[pd.DataFrame]:
    # ... (日期计算和 run_config 准备逻辑不变) ...
    
    # --- 流水线变更 ---
    df = _get_ohlcv_data_bs(api_ticker, start_date_str, end_date_str, run_config)
    if df is None or df.empty: return None

    # 1. (新) 加载因子数据
    factors_df = get_fama_french_factors(start_date_str, end_date_str)
    
    # 2. 宏观数据
    macro_df = _get_macroeconomic_data_cn(start_date_str, end_date_str, run_config)
    if macro_df is not None: df = pd.merge_asof(df, macro_df, left_index=True, right_index=True)

    # 3. 技术/日历特征
    df = feature_calculators.run_all_feature_calculators(df, run_config)
    
    # 4. 【已移除】相对表现特征，由因子模型替代
    
    # 5. 平稳化 (现在不需要平稳化 benchmark_close 等)
    df = _make_features_stationary(df, run_config)
    
    # 6. 【已重构】计算 Alpha 标签
    df = _calculate_alpha_label(df, factors_df, run_config)
    
    # 7. 初步特征筛选
    df = _initial_feature_selection(df, run_config)
    
    # ... (后续的数据清洗和校验逻辑不变) ...
    
    return df

# ... (process_all_from_config 保持不变)
```

##### **第三步：修改 `config.yaml`**

我们的预测目标已经变了，需要更新配置文件中的标签列名。

```yaml
# configs/config.yaml

global_settings:
  # ...
  # --- 核心修正：将标签列名更新为 alpha ---
  label_column: 'label_alpha'
  # ---
  # ...
```

### **操作步骤**

1.  **创建新文件**: 在 `data_process/` 目录下创建 `factor_data.py` 并粘贴代码。
2.  **安装新库**: `statsmodels` 是一个新的依赖，请安装它：`pip install statsmodels`。
3.  **修改 `get_data.py`**: 用我上面提供的**最终多因子版**的**完整内容**，彻底覆盖您现有的 `get_data.py` 文件。
4.  **修改 `config.yaml`**: 将 `global_settings` 下的 `label_column` 修改为 `label_alpha`。
5.  **清除所有缓存**:
    *   **手动删除 `data_cache/` 文件夹**。
    *   **手动删除 `data/processed/` 文件夹**。
6.  **重新运行 `train.ipynb`**:
    *   **重启内核** (Kernel -> Restart & Clear Output)。
    *   从头开始，完整地运行**阶段一**和**阶段二**。

### **最终预期效果**

*   您的模型现在训练和预测的目标，不再是“未来股价会不会涨”，而是“**在剔除了大盘涨跌、大小盘风格轮动和价值/成长风格轮动的影响后，这只股票自身的超额收益（Alpha）是正是负**”。
*   您最终评估报告中的 IC 和 ICIR，将衡量您的模型**捕捉纯粹 Alpha** 的能力。这在学术界和业界都被认为是**更高级、更可靠**的策略评估方式。
*   由于 Alpha 的波动性通常远小于原始收益率，您可能会发现模型的 IC 均值和 ICIR 的**绝对数值有所下降**，这是**完全正常**的。但这个新的、更低的 ICIR，含金量更高，因为它代表了更稀缺、更难以被市场解释的超额收益。

---

#### **3. 扩展股票池**
*   **当前状态**: 我们的股票池只有 7 只股票。
*   **优化方向**: 将 `stocks_to_process` 列表扩展到您所在行业或您感兴趣的更多股票（例如 30-50 只）。
*   **具体操作**: 在 `config.yaml` 中，按照现有格式添加新的股票条目。
*   **预期效果**: 在更大的样本上检验您策略的**普适性**。如果模型在扩展后的股票池上依然表现良好，那将极大地增强您对这个策略的信心。

---

### **【中期优化】 深度挖掘模型与策略潜力**

这些优化需要一定的代码修改和更深入的研究。

#### **4. 开启并优化 LSTM 模型**
*   **当前状态**: 我们已经为 LSTM 搭建了完整的训练框架，但可能还没有对其进行精细的调优。
*   **优化方向**:
    1.  **为 LSTM 添加 HPO**: 模仿 `hpo_utils.py` 中 `lgbm` 的逻辑，为 `lstm` 添加它的超参数搜索空间（`sequence_length`, `units_1`, `dropout`, `learning_rate` 等）。
    2.  **优化 LSTM 特征**: 深度学习模型对特征的**归一化**和**平稳性**要求更高。您可以尝试不同的 Scaler (如 `MinMaxScaler`)，或者对更多特征进行差分、取对数等操作，看看是否能提升 LSTM 的表现。
*   **预期效果**: 释放 LSTM 作为序列模型的全部潜力。一个调优良好的 LSTM 可能会在捕捉长期依赖关系方面超越 LGBM。

#### **5. 引入新的基础模型 (Model Stacking 扩展)**
*   **当前状态**: 我们的融合框架是基于 LGBM 和 LSTM。
*   **优化方向**: 引入与现有模型**差异性大**的新模型，可以最大化集成学习带来的收益。
    *   **XGBoost / CatBoost**: 在 `model_builders/` 下创建 `xgb_builder.py`，实现与 `LGBMBuilder` 类似的接口。
    *   **Transformer**: 创建 `transformer_builder.py`，利用其注意力机制来捕捉更复杂的时序关系。
*   **具体操作**:
    1.  创建新的 builder.py 文件。
    2.  在 `config.yaml` 的 `models_to_train` 中加入新模型的名字。
    3.  `ModelFuser` 会**自动**识别并将其纳入融合训练，无需修改 `ModelFuser` 的代码。
*   **预期效果**: 增加模型的多样性，有望使最终的融合模型更加稳健。

#### **6. 优化融合策略 (元模型)**
*   **当前状态**: `ModelFuser` 主要使用 `Ridge` 回归。
*   **优化方向**: 在 `config.yaml` 的 `fuser_params` 中，将 `type` 从 `ridge` 改为 `mlp`，启用非线性融合。
    ```yaml
    fuser_params:
      type: 'mlp'
    ```
*   **预期效果**: 如果基础模型之间的关系是非线性的，`MLPRegressor` 可能会学习到更复杂的融合规则，从而超越简单的线性融合。

---

### **【长期优化】 迈向完整的实盘系统**

这些是构建一个全自动量化交易系统所需的宏大工程。

#### **7. 构建向量化回测引擎**
*   **当前状态**: 我们只有基于 Walk-Forward 的 IC 评估，这衡量的是模型的“选股能力”，而不是“策略盈利能力”。
*   **优化方向**: 创建一个新的 `Backtester.ipynb` 或 `backtest.py` 模块。
    *   **输入**: OOF 预测文件 (`_oof_preds.csv`) 或融合模型的预测结果。
    *   **逻辑**: 根据预测信号（例如，信号 > 阈值则买入），模拟每日的开仓、平仓、持仓，并考虑交易成本和滑点。
    *   **输出**: 策略的**资金曲线、年化收益、最大回撤、夏普比率**等最终的、衡量“赚钱能力”的指标。
*   **预期效果**: 这是从“模型”到“策略”的决定性一步。

#### **8. 部署实盘交易系统**
*   **当前状态**: 我们的 `Prophet.ipynb` 是一个手动的预测工具。
*   **优化方向**:
    1.  将 `Prophet.ipynb` 和 `Incremental_Update.ipynb` 的逻辑整合并脚本化（`.py` 文件）。
    2.  创建一个调度器（例如，使用 `APScheduler` 库或操作系统的定时任务 `cron`/`Scheduled Tasks`），让这些脚本在每个交易日收盘后**自动运行**。
    3.  对接真实的券商交易 API（如华泰、中信建投等的 API）。
    4.  当 `ModelFuser` 生成交易信号后，不再是打印报告，而是调用交易 API 自动下单。
*   **预期效果**: 实现无人值守的全自动量化交易。

---

### **您的下一步行动建议**

1.  **立即执行【短期优化】中的第 1 步**: **更换基准指数**。这是对您现有研究成果科学性的一个重要加固。
2.  **然后，探索第 2 和第 3 步**: 尝试增加一些新特征和新股票，看看模型的表现如何变化。
3.  **当您准备好后，挑战【中期优化】**: 开始着手为 LSTM 进行 HPO，这是提升模型性能的下一个大金矿。

您的项目已经拥有了一个极好的基础，未来的探索将充满乐趣和挑战。祝您在量化之路上不断取得新的突破！